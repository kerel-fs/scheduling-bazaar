{"type":"settings","kernel":"anaconda3","backend_state":"running","trust":true,"kernel_state":"idle"}
{"type":"file","last_load":1497969416586}
{"exec_count":10,"start":1497971820590,"input":"# Notebook to test all functions and classes to be included in the scheduling module","state":"done","pos":0,"type":"cell","end":1497971820593,"id":"270bfd","kernel":"anaconda3"}
{"exec_count":18,"start":1497971870670,"input":"class TLE:\n    \"\"\"TLE class used for various tle attributes.\n    \n    Args: a three element list containing tle lines\n    \"\"\"\n    def __init__(self, tle):\n        self.tle = tle\n        self.tle0 = tle[0]\n        self.tle1 = tle[1]\n        self.tle2 = tle[2]\n        self.name = tle[0].rstrip()\n        self.noradid = tle[1][2:7]\n        self.epoch = tle[1][18:32]\n        self.inclination = tle[2][8:16]\n\n    def __str__(self):\n        return '%s\\n%s\\n%s' % (self.tle0, self.tle1, self.tle2)\n","state":"done","pos":1,"type":"cell","end":1497971870676,"id":"a5d86d","kernel":"anaconda3"}
{"exec_count":34,"start":1497973089670,"input":"# plot_access_time() function definition\ndef plot_access_time(start, gs, tle, days):\n    \"\"\"Plots Access Time in seconds/day.\n\n    Arguments:\n    start -- string formatted 'yyyy/mm/dd HH:MM:SS'\n    gs -- 4 element list containing desired [name,lat,lon,alt]\n    tle -- 3 element list containing desired tle [line0,line1,line2]\n    days -- num of day to calc/plot access time\n    \"\"\"\n    tle = TLE(tle)\n\n    day_list, access_list = calc_access_time(start, gs, tle, days)\n\n    fig = plt.figure(1)\n    fig.suptitle('%s Access time for %s GS' % (tle.name, gs[0]))\n\n    s1 = plt.subplot(221)\n    s1.plot(day_list, access_list, 'b.')\n    plt.xlabel('Days from %s' % (start))\n    plt.ylabel('Access time (sec/day)')\n\n    plt.subplot(222)\n    plt.plot(day_list, access_list, 'b-')\n    plt.xlabel('Days from %s' % (start))\n\n    plt.show()\n","state":"done","pos":2,"type":"cell","end":1497973089679,"id":"90afa4","kernel":"anaconda3"}
{"exec_count":29,"input":"# TEST CASES\n\nvu = ['Valparaiso University', '41.4639', '-87.0439', 245.089]\nstart_time = '2017/6/8 00:00:00'\nnum_passes = None\nduration = 24.0\nvu_passes = {}\n\ndata = get_tles('amateur.txt')\n\nfor tle in data:\n    # use NORAD ID as key for each satellite\n    # value is list of passes, where each pass is a dictionary of data\n    noradID = tle[2][2:7]\n    vu_passes[noradID] = new_get_passes(vu, tle, start_time, num_passes=num_passes, duration=duration)\n","scrolled":true,"state":"done","pos":3,"type":"cell","id":"77a621","kernel":"anaconda3"}
{"exec_count":24,"start":1497971931870,"input":"# get_passes() function definition\ndef new_get_passes(observer, tle, start_time, num_passes=None, duration=None):\n    \"\"\"Config obs and sat, Return pass data for all passes in given interval.\n\n    Arguments:\n    observer -- 4 element list containing desired [name,lat,lon,alt]\n    tle -- 3 element list containing desired tle [line0,line1,line2]\n    start_time -- ephem.date string formatted 'yyyy/mm/dd hr:min:sec'\n    num_passes -- integer number of desired passes (defualt None)\n    duration -- float number of hours or fraction of hours (default None)\n\n    Specify either num_passes or duration.\n    If both, use min(num_passes, duration).\n    If neither, find passes for next 24 hours.\n    \"\"\"\n\n    obs_name, obs_lat, obs_lon, obs_alt = observer\n    tle_line0, tle_line1, tle_line2 = tle\n\n    # Set up location of observer\n    ground_station = ephem.Observer()\n    ground_station.name = obs_name                # name string\n    ground_station.lon = obs_lon                  # in degrees (+E)\n    ground_station.lat = obs_lat                  # in degrees (+N)\n    ground_station.elevation = obs_alt            # in meters\n    ground_station.date = ephem.date(start_time)  # in UTC\n\n    # Read in most recent satellite TLE data\n    sat = ephem.readtle(tle_line0, tle_line1, tle_line2)\n\n    contacts = []\n\n    if duration is None and num_passes is None:\n        # get passes for next 24 hrs\n        duration = 24\n        # set num_passes > max passes possible in duration.\n        # duration is in hours, so 4 per hour is large\n        # enough for duration to break out of loop.\n        num_passes = 4 * int(duration)\n        # set end_time longer than suggested length for tle's\n        end_time = ephem.date(ground_station.date+5*365)\n    if duration is not None and num_passes is None:\n        # set num_passes > max passes possible in duration.\n        # duration is in hours, so 4 per hour is large\n        # enough for duration to break out of loop.\n        num_passes = 4 * int(duration)\n        end_time = ephem.date(ground_station.date+duration*ephem.hour)\n    if duration is None and num_passes is not None:\n        # set end_time longer than suggested length for tle's\n        end_time = ephem.date(ground_station.date+5*365)\n    if num_passes is not None and duration is not None:\n        # if both are given, use minimum\n        end_time = ephem.date(ground_station.date+duration*ephem.hour)\n\n    try:\n        for i in range(num_passes):\n            if ground_station.date > end_time:\n                break\n            sat.compute(ground_station)  # compute all body attributes for sat\n            # next pass command yields array with [0]=rise time,\n            # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n            # [4]=set time, [5]=set azimuth\n            info = ground_station.next_pass(sat)\n            rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n            deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n            try:\n                pass_duration = timedelta(days=set_time-rise_time)  # timedelta\n                r_angle = (rise_az*deg_per_rad)\n                s_angle = (set_az*deg_per_rad)\n            except TypeError:\n                # when no set or rise time\n                pass\n            try:\n                rising = rise_time.datetime().ctime()\n                setting = set_time.datetime().ctime()\n                pass_seconds = timedelta.total_seconds(pass_duration)\n            except AttributeError:\n                # when no set or rise time\n                pass\n\n            pass_data = {\n                'start': rising,\n                'end': setting,\n                'duration': pass_seconds,\n                'rise_az': r_angle,\n                'set_az': s_angle,\n            }\n\n            try:\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time  # new obs time = prev set time\n                    if ground_station.date <= end_time:\n                        contacts.append(pass_data)\n            except TypeError:\n                pass\n\n            # increase by 1 min and look for next pass\n            ground_station.date = ground_station.date + ephem.minute\n    except ValueError:\n        # No (more) visible passes\n        pass\n    return contacts\n","state":"done","pos":1.5,"type":"cell","end":1497971932131,"id":"fba2df","kernel":"anaconda3"}
{"exec_count":23,"start":1497971930272,"input":"# get_tles() function definition\ndef get_tles(file):\n    \"\"\"Returns a list of tle's from a file.\n\n    Arguments:\n    file -- file name string containing unparsed tles\n    \"\"\"\n    data = []\n    with open(file) as f:\n        while True:\n            #an iterator that returns the next N lines and stops\n            tripleline = islice(f, 3)\n            #loop over these N lines, removing trailing spaces and \\n\n            tle = [x.rstrip() for x in tripleline]\n\n            #only accept complete data\n            #the end of the file *should* have len(tle)==0 but\n            #this also handles extra junk at the end\n            if len(tle) == 3:\n                data.append(tle)\n            else:\n                break\n    return data","state":"done","pos":1.25,"type":"cell","end":1497971930287,"id":"ed63f8","kernel":"anaconda3"}
{"exec_count":31,"start":1497973024717,"input":"# Import necessary libraries\nimport ephem\nimport math\nimport seaborn\nfrom datetime import timedelta\nfrom itertools import islice\nimport matplotlib.pyplot as plt\n","state":"done","pos":0.5,"type":"cell","end":1497973024772,"id":"bc804f","kernel":"anaconda3"}
{"exec_count":33,"start":1497973087782,"input":"# calc_access_time() function definition\ndef calc_access_time(start, gs, tle, days):\n    \"\"\"Calculates Access Time in seconds/day.\n\n    Arguments:\n    start -- string formatted 'yyyy/mm/dd HH:MM:SS'\n    gs -- 4 element list containing desired [name,lat,lon,alt]\n    tle -- 3 element list containing desired tle [line0,line1,line2]\n    days -- num of day to calc/plot access time\n    \"\"\"\n    time = days\n    start_time = ephem.date(start)\n    access_list = []\n    day_list = []\n    #tle = TLE(tle)\n\n    for days in range(time):\n        num_passes = None\n        duration = 24.0\n        gs_passes = {}\n\n        gs_passes[tle.noradid] = new_get_passes(gs, tle.tle, start_time, num_passes=num_passes, duration=duration)\n\n        access_time = 0\n        for sat, passes in gs_passes.items():\n            for obs in passes:\n                access_time = access_time + obs['duration']\n        access_list.append(access_time)\n        day_list.append(days)\n        start_time = start_time + 1\n    return day_list, access_list\n","state":"done","pos":1.75,"type":"cell","end":1497973087813,"id":"5e5339","kernel":"anaconda3"}
{"output":{"0":{"metadata":{"image/png":{"height":220,"width":504}},"data":{"image/png":"387fa6951b6607f8a98609c538255bdfd7d2b474"}}},"exec_count":36,"input":"# TEST CASES\n\ncs = ['Corey Shields', '39.236', '-86.305', 280]\ntle = ['UPSAT                   ','1 42716U 98067LX  17166.72694047  .00011068  00000-0  16523-3 0  9996','2 42716  51.6407  45.3505 0004198 326.8454  33.2274 15.55584668  4414']\nstart = '2017/6/8 00:00:00'\n\nplot_access_time(start, cs, tle, 365)","state":"done","pos":4,"type":"cell","id":"303242","kernel":"anaconda3"}