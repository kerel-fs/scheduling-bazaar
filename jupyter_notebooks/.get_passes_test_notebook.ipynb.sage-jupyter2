{"type":"settings","kernel":"anaconda3","backend_state":"running","trust":true,"kernel_state":"idle"}
{"type":"file","last_load":1496169449559}
{"exec_count":1,"start":1496771650379,"input":"# Import necessary libraries\nimport ephem\nimport math\nfrom datetime import datetime\n#from time import strftime","state":"done","pos":0,"type":"cell","end":1496771650546,"id":"4323d4","kernel":"anaconda3"}
{"exec_count":2,"start":1496771650876,"input":"# get_passes() function definition\n# \n\ndef get_passes(observer,tle,start_time,num_passes):\n\n    obs_name, obs_lat, obs_lon, obs_alt = observer\n    tle_line0, tle_line1, tle_line2 = tle\n    start = ephem.date(start_time)\n\n    # Set up location of observer\n    ground_station = ephem.Observer()\n    ground_station.name = obs_name\n    ground_station.lon = obs_lon                  # in degrees (+E)\n    ground_station.lat = obs_lat                  # in degrees (+N)\n    ground_station.elevation = obs_alt            # in meters\n    ground_station.date = start                   # in UTC (begin looking for next sat passes)\n\n    # Read in most recent satellite TLE data\n    sat = ephem.readtle(tle_line0, tle_line1,tle_line2)\n\n    # Find all passes during duration\n    i = 0\n    pass_data = {}\n    for i in range(num_passes):\n        sat.compute(ground_station)                              # compute all body attributes for sat\n        # next pass command yields array with [0]=rise time, [1]=rise azimuth, [2]=max alt time, [3]=max alt, [4]=set time, [5]=set azimuth\n        info = ground_station.next_pass(sat)\n        rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n        deg_per_rad = 180.0/math.pi                              # use to display azimuth in degrees\n        pass_duration = (set_time-rise_time)                     # (set time - rise time) --> fraction of a day\n\n        if set_time > rise_time:                                 # only update if the set time is greater than the rise time\n            ground_station.date = set_time                       # new observer date & time = previous set time\n\n        pass_data[i] = [rise_time, set_time, pass_duration, (rise_az*deg_per_rad), (set_az*deg_per_rad)]\n        #i = i + 1\n        ground_station.date = ground_station.date + ephem.minute # increase time by 1 min and look for next pass\n    return pass_data","state":"done","pos":1,"type":"cell","end":1496771650917,"id":"a29b2d","kernel":"anaconda3"}
{"output":{"0":{"name":"stdout","text":"2017/5/30 12:00:00\n(2017, 5, 30, 12, 0, 0.0)\n2017/5/30 12:00:00\n42884.000000\n42884.041666666664\n2017/5/30 13:00:00\n"}},"exec_count":3,"start":1496771650926,"input":"from datetime import date, datetime\nnow = ephem.date('2017/5/30 12:00:00')\nprint(ephem.date(now))\nprint(now.tuple())\nprint(now)\nprint('%.6f' % now)\nprint(now + ephem.hour)\nprint(ephem.date(now + ephem.hour))","state":"done","pos":2,"type":"cell","end":1496771650942,"id":"90136c","kernel":"anaconda3"}
{"output":{"0":{"name":"stdout","text":"[42884.434691182, 42884.43991920763, 0.005228025627729949, 169.3898798692318, 82.07670985969658]\n[42884.50003979661, 42884.5076599303, 0.007620133692398667, 224.0069548124835, 57.50470133941467]\n[42884.5673264383, 42884.57464997139, 0.00732353309285827, 265.9121597857494, 51.11262782352322]\n[42884.635205144965, 42884.64197067463, 0.00676552966615418, 296.4929111151341, 60.73552425080327]\n[42884.70261850134, 42884.709823333724, 0.007204832385468762, 308.6423969692394, 89.18613765354696]\n[42884.76961509613, 42884.77724968808, 0.007634591951500624, 304.12212313501163, 130.06104957165144]\n[42884.83714153454, 42884.84296395175, 0.005822417209856212, 282.9471979908948, 182.04994968455227]\n[42885.40006615611, 42885.402609394936, 0.0025432388283661567, 141.46799824032797, 101.89370460435568]\n[42885.46403380888, 42885.47138834576, 0.00735453687957488, 209.8578764373436, 62.207921790561265]\n[42885.53090961274, 42885.53843875804, 0.007529145303124096, 254.34143684115426, 51.54580183578001]\n[42885.598744455754, 42885.60559309455, 0.006848638797237072, 289.10873896192, 55.89650597857849]\n[42885.666350173495, 42885.67334304691, 0.006992873415583745, 307.0160196448327, 79.04153771708299]\n[42885.733401703015, 42885.74102798578, 0.007626282764249481, 306.9374178278642, 117.04261339095873]\n[42885.800608924, 42885.80741434049, 0.006805416487623006, 291.83351998789146, 164.53521363361853]\n[42886.42821978558, 42886.43501324355, 0.006793457971070893, 194.44675668850374, 68.62931730855958]\n[42886.494570947514, 42886.502230695725, 0.007659748211153783, 242.0061698416246, 53.2315061833175]\n[42886.56224794223, 42886.56926925032, 0.007021308090770617, 280.1674749232397, 52.796474359606464]\n[42886.630017238334, 42886.63685127267, 0.006834034335042816, 303.7631283922358, 70.21938534733854]\n[42886.697189198305, 42886.704683630574, 0.007494432269595563, 308.5312014895516, 104.72968794020419]\n[42886.76423687122, 42886.771584902, 0.007348030783759896, 298.1567451969492, 149.1595289061927]\n"}},"exec_count":4,"start":1496771650965,"input":"vu = ['Valparaiso University', '41.4639', '-87.0439', 245.089]\ntle = ['ISS', '1 25544U 98067A   17144.56334412  .00016717  00000-0  10270-3 0  9002', '2 25544  51.6383 156.0737 0005162 190.1606 169.9443 15.53944016 18074']\nstart_time = '2017/5/30 12:00:00'\nnum_passes = 20\n\npass_data = get_passes(vu,tle,start_time,num_passes)\n\nfor i in range(num_passes):\n    print(pass_data[i])\n#print(pass_data)","state":"done","pos":3,"type":"cell","end":1496771651056,"id":"03d3ce","kernel":"anaconda3"}
{"exec_count":6,"start":1496772386413,"input":"# get_passes() function prior to 6/6/17\n\n\n# get_passes() function\n# This function will take in a 3 element list of observer data containing [name,latitude,longitude,altitude],\n# a 3 element list of satellite TLE data, a start time formatted as an ephem date, and a desired number of passes to find\n# EX: vu = ['Valparaiso University', '41.4639', '-87.0439', 245.089]\n#     tle = ['ISS', '1 25544U 98067A   17144.56334412  .00016717  00000-0  10270-3 0  9002', '2 25544  51.6383 156.0737 0005162 190.1606 169.9443 15.53944016 18074']\n#     start_time = '2017/5/30 12:00:00'\n#     num_passes = 20\n# This function will return a list called pass_data with number of elements = num_passes.\n# Each element in pass_data is a 5-element list containing:\n#    rise_time (ephem date), set_time (ephem date), pass_duration (as fraction of a day), rise_az (in deg), set_az (in deg)\n# for each pass.\n\n# Import necessary libraries\nimport ephem\nimport math\nfrom datetime import datetime\n\n# get_passes() function definition\ndef get_passes(observer,tle,start_time,num_passes):\n    \"\"\"lkjhgkjhgjkghkjhg\"\"\"\n\n    obs_name, obs_lat, obs_lon, obs_alt = observer\n    tle_line0, tle_line1, tle_line2 = tle\n    start = ephem.date(start_time)\n\n    # Set up location of observer\n    ground_station = ephem.Observer()\n    ground_station.name = obs_name                                           # name string\n    ground_station.lon = obs_lon                                             # in degrees (+E)\n    ground_station.lat = obs_lat                                             # in degrees (+N)\n    ground_station.elevation = obs_alt                                       # in meters\n    ground_station.date = start                                              # in UTC (begin looking for next sat passes at this time)\n\n    # Read in most recent satellite TLE data\n    sat = ephem.readtle(tle_line0, tle_line1,tle_line2)\n\n    # Find all passes during duration\n    i = 0\n    pass_data = {}\n    for i in range(num_passes):\n        sat.compute(ground_station)                                          # compute all body attributes for sat\n        # next pass command yields array with [0]=rise time, [1]=rise azimuth, [2]=max alt time, [3]=max alt, [4]=set time, [5]=set azimuth\n        info = ground_station.next_pass(sat)\n        rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n        deg_per_rad = 180.0/math.pi                                          # use to display azimuth in degrees\n        pass_duration = (set_time-rise_time)                                 # (set time - rise time) --> fraction of a day\n\n        if set_time > rise_time:                                             # only update if the set time is greater than the rise time\n            ground_station.date = set_time                                   # new observer date & time = previous set time\n\n        pass_data[i] = [rise_time, set_time, pass_duration, (rise_az*deg_per_rad), (set_az*deg_per_rad)]\n\n        ground_station.date = ground_station.date + ephem.minute             # increase time by 1 min and look for next pass\n    return pass_data                                                         # return list of 5-element pass predictions","state":"done","pos":4,"type":"cell","end":1496772386529,"id":"e3a26c","kernel":"anaconda3"}
{"exec_count":44,"start":1496781084507,"input":"# 6/6/17 get_passes() edits\n\n# Import necessary libraries\nimport ephem\nimport math\nfrom datetime import datetime\n\n# get_passes() function definition\ndef get_passes_two(observer,tle,start_time,num_passes=None,duration=None):\n    \"\"\"Configure observer and satellite, Return pass data for all passes in given interval.\n    \n    Arguments:\n    observer -- 4 element list containing desired [name,lat,lon,alt]\n    tle -- 3 element list containing desired tle [line0,line1,line2]\n    start_time -- ephem.date string formatted 'yyyy/mm/dd hr:min:sec'\n    num_passes -- integer number of desired passes (defualt None)\n    duration -- float number of hours or fraction of hours (default None)\n    \n    Specify either num_passes or duration.\n    If both, use num_passes.\n    If neither, find passes for next 24 hours.\n    \"\"\"\n    \n    obs_name, obs_lat, obs_lon, obs_alt = observer\n    tle_line0, tle_line1, tle_line2 = tle\n    \n    # Set up location of observer\n    ground_station = ephem.Observer()\n    ground_station.name = obs_name                                           # name string\n    ground_station.lon = obs_lon                                             # in degrees (+E)\n    ground_station.lat = obs_lat                                             # in degrees (+N)\n    ground_station.elevation = obs_alt                                       # in meters\n    ground_station.date = ephem.date(start_time)                             # in UTC (begin looking for next sat passes at this time)\n\n    # Read in most recent satellite TLE data\n    sat = ephem.readtle(tle_line0, tle_line1,tle_line2)\n    \n    pass_data = {}\n    i=0\n    \n    if num_passes!=None and duration==None:\n        # if only num_passes specified\n        for i in range(num_passes):\n            sat.compute(ground_station)                                          # compute all body attributes for sat\n            # next pass command yields array with [0]=rise time, [1]=rise azimuth, [2]=max alt time, [3]=max alt, [4]=set time, [5]=set azimuth\n            info = ground_station.next_pass(sat)\n            rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n            deg_per_rad = 180.0/math.pi                                          # use to display azimuth in degrees\n            pass_duration = (set_time-rise_time)                                 # (set time - rise time) --> fraction of a day\n\n            if set_time > rise_time:                                             # only update if the set time is greater than the rise time\n                ground_station.date = set_time                                   # new observer date & time = previous set time\n\n            pass_data[i] = [rise_time, set_time, pass_duration, (rise_az*deg_per_rad), (set_az*deg_per_rad)]\n\n            ground_station.date = ground_station.date + ephem.minute             # increase time by 1 min and look for next pass\n        return pass_data\n    if num_passes==None and duration!=None:\n        # if only duration specified\n        end_time = ephem.date(ground_station.date+duration*ephem.hour)\n        while (ground_station.date <= end_time):\n            sat.compute(ground_station)                                          # compute all body attributes for sat\n            # next pass command yields array with [0]=rise time, [1]=rise azimuth, [2]=max alt time, [3]=max alt, [4]=set time, [5]=set azimuth\n            info = ground_station.next_pass(sat)\n            rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n            deg_per_rad = 180.0/math.pi                                          # use to display azimuth in degrees\n            pass_duration = (set_time-rise_time)                                 # (set time - rise time) --> fraction of a day\n\n            if set_time > rise_time:                                             # only update if the set time is greater than the rise time\n                ground_station.date = set_time                                   # new observer date & time = previous set time\n\n            pass_data[i] = [rise_time, set_time, pass_duration, (rise_az*deg_per_rad), (set_az*deg_per_rad)]\n\n            i=i+1\n            ground_station.date = ground_station.date + ephem.minute             # increase time by 1 min and look for next pass\n        return pass_data\n    if num_passes!=None and duration!=None:\n        # if both are specified, use num_passes\n        for i in range(num_passes):\n            sat.compute(ground_station)                                          # compute all body attributes for sat\n            # next pass command yields array with [0]=rise time, [1]=rise azimuth, [2]=max alt time, [3]=max alt, [4]=set time, [5]=set azimuth\n            info = ground_station.next_pass(sat)\n            rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n            deg_per_rad = 180.0/math.pi                                          # use to display azimuth in degrees\n            pass_duration = (set_time-rise_time)                                 # (set time - rise time) --> fraction of a day\n\n            if set_time > rise_time:                                             # only update if the set time is greater than the rise time\n                ground_station.date = set_time                                   # new observer date & time = previous set time\n\n            pass_data[i] = [rise_time, set_time, pass_duration, (rise_az*deg_per_rad), (set_az*deg_per_rad)]\n\n            ground_station.date = ground_station.date + ephem.minute             # increase time by 1 min and look for next pass\n        return pass_data\n    if num_passes==None and duration==None:\n        # if neither are specified, get passes for the next 24 hours\n        end_time = ephem.date(ground_station.date+1)\n        while (ground_station.date <= end_time):\n            sat.compute(ground_station)                                          # compute all body attributes for sat\n            # next pass command yields array with [0]=rise time, [1]=rise azimuth, [2]=max alt time, [3]=max alt, [4]=set time, [5]=set azimuth\n            info = ground_station.next_pass(sat)\n            rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n            deg_per_rad = 180.0/math.pi                                          # use to display azimuth in degrees\n            pass_duration = (set_time-rise_time)                                 # (set time - rise time) --> fraction of a day\n\n            if set_time > rise_time:                                             # only update if the set time is greater than the rise time\n                ground_station.date = set_time                                   # new observer date & time = previous set time\n\n            pass_data[i] = [rise_time, set_time, pass_duration, (rise_az*deg_per_rad), (set_az*deg_per_rad)]\n\n            i=i+1\n            ground_station.date = ground_station.date + ephem.minute             # increase time by 1 min and look for next pass\n        return pass_data","state":"done","pos":6,"type":"cell","end":1496781084871,"id":"62879f","kernel":"anaconda3"}
{"output":{"0":{"name":"stdout","text":"2017/5/30 12:00:00\n2017/5/31 00:33:00\n"}},"exec_count":24,"start":1496774556271,"input":"start_time = '2017/5/30 12:00:00'\nstart = ephem.date(start_time)\nduration = 12.55\nprint(start)\nprint(ephem.date(start+duration*ephem.hour))","state":"done","pos":5,"type":"cell","end":1496774556279,"id":"3aa218","kernel":"anaconda3"}
{"output":{"0":{"name":"stdout","text":"{0: [42884.434691182, 42884.43991920763, 0.005228025627729949, 169.3898798692318, 82.07670985969658], 1: [42884.50003979661, 42884.5076599303, 0.007620133692398667, 224.0069548124835, 57.50470133941467], 2: [42884.5673264383, 42884.57464997139, 0.00732353309285827, 265.9121597857494, 51.11262782352322], 3: [42884.635205144965, 42884.64197067463, 0.00676552966615418, 296.4929111151341, 60.73552425080327], 4: [42884.70261850134, 42884.709823333724, 0.007204832385468762, 308.6423969692394, 89.18613765354696], 5: [42884.76961509613, 42884.77724968808, 0.007634591951500624, 304.12212313501163, 130.06104957165144], 6: [42884.83714153454, 42884.84296395175, 0.005822417209856212, 282.9471979908948, 182.04994968455227], 7: [42885.40006615611, 42885.402609394936, 0.0025432388283661567, 141.46799824032797, 101.89370460435568]}\n"}},"exec_count":45,"start":1496781202470,"input":"vu = ['Valparaiso University', '41.4639', '-87.0439', 245.089]\ntle = ['ISS', '1 25544U 98067A   17144.56334412  .00016717  00000-0  10270-3 0  9002', '2 25544  51.6383 156.0737 0005162 190.1606 169.9443 15.53944016 18074']\nstart_time = '2017/5/30 12:00:00'\nnum_passes = 20\nduration = 10.5\n\npass_data = get_passes_two(vu,tle,start_time,num_passes=None,duration=None)\n    \nprint(pass_data)","state":"done","pos":7,"type":"cell","end":1496781202507,"id":"5c05cf","kernel":"anaconda3"}
{"output":{"0":{"name":"stdout","text":"Help on function get_passes_two in module __main__:\n\nget_passes_two(observer, tle, start_time, num_passes=None, duration=None)\n    Configure observer and satellite, Return pass data for all passes in given interval.\n    \n    Arguments:\n    observer -- 4 element list containing desired [name,lat,lon,alt]\n    tle -- 3 element list containing desired tle [line0,line1,line2]\n    start_time -- ephem.date string formatted 'yyyy/mm/dd hr:min:sec'\n    num_passes -- integer number of desired passes (defualt None)\n    duration -- float number of hours or fraction of hours (default None)\n    \n    Specify either num_passes or duration.\n    If both, use num_passes.\n    If neither, find passes for next 24 hours.\n\n"}},"exec_count":46,"input":"get_passes_two?","state":"done","pos":8,"type":"cell","id":"11a423","kernel":"anaconda3"}