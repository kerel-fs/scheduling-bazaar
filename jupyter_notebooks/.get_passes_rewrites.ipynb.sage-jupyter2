{"type":"settings","kernel":"anaconda3","backend_state":"running","trust":true,"kernel_state":"idle"}
{"type":"file","last_load":1497468260616}
{"exec_count":34,"start":1497471954338,"input":"# Import necessary libraries\nimport ephem\nimport math\nfrom datetime import timedelta\nfrom datetime import datetime\n\n\n# get_passes() function definition\ndef get_passes(observer, tle, start_time, num_passes=None, duration=None):\n    \"\"\"Config obs and sat, Return pass data for all passes in given interval.\n\n    Arguments:\n    observer -- 4 element list containing desired [name,lat,lon,alt]\n    tle -- 3 element list containing desired tle [line0,line1,line2]\n    start_time -- ephem.date string formatted 'yyyy/mm/dd hr:min:sec'\n    num_passes -- integer number of desired passes (defualt None)\n    duration -- float number of hours or fraction of hours (default None)\n\n    Specify either num_passes or duration.\n    If both, use num_passes.\n    If neither, find passes for next 24 hours.\n    \"\"\"\n\n    obs_name, obs_lat, obs_lon, obs_alt = observer\n    tle_line0, tle_line1, tle_line2 = tle\n\n    # Set up location of observer\n    ground_station = ephem.Observer()\n    ground_station.name = obs_name                # name string\n    ground_station.lon = obs_lon                  # in degrees (+E)\n    ground_station.lat = obs_lat                  # in degrees (+N)\n    ground_station.elevation = obs_alt            # in meters\n    ground_station.date = ephem.date(start_time)  # in UTC\n\n    # Read in most recent satellite TLE data\n    sat = ephem.readtle(tle_line0, tle_line1, tle_line2)\n\n    contacts = []\n\n    if num_passes is not None and duration is None:\n        # if only num_passes specified\n        try:\n            for i in range(num_passes):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = timedelta(days = set_time-rise_time)  # fraction of a day\n\n                pass_data = {\n                    'start' : rise_time.datetime().ctime(),\n                    'end' : set_time.datetime().ctime(),\n                    'duration' : str(pass_duration),\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time  # new obs time = prev set time\n                    contacts.append(pass_data)\n\n                # increase by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return contacts\n\n    if num_passes is None and duration is not None:\n        # if only duration specified\n        try:\n            end_time = ephem.date(ground_station.date+duration*ephem.hour)\n            while (ground_station.date <= end_time):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = timedelta(set_time-rise_time)  # fraction of a day\n\n                pass_data = {\n                    'start' : rise_time.datetime().ctime(),\n                    'end' : set_time.datetime().ctime(),\n                    'duration' : str(pass_duration),\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time  # new obs time = prev set time\n                    contacts.append(pass_data)\n\n                # increase time by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return contacts\n\n    if num_passes is not None and duration is not None:\n        # if both are specified, use num_passes\n        try:\n            for i in range(num_passes):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = timedelta(set_time-rise_time)  # fraction of a day\n\n                pass_data = {\n                    'start' : rise_time.datetime().ctime(),\n                    'end' : set_time.datetime().ctime(),\n                    'duration' : str(pass_duration),\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time   # new obs time = prev set time\n                    contacts.append(pass_data)\n\n                # increase time by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return contacts\n\n    if num_passes is None and duration is None:\n        # if neither are specified, get passes for the next 24 hours\n        try:\n            end_time = ephem.date(ground_station.date+1)\n            while (ground_station.date <= end_time):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = timedelta(set_time-rise_time)  # fraction of a day\n\n                pass_data = {\n                    'start' : rise_time.datetime().ctime(),\n                    'end' : set_time.datetime().ctime(),\n                    'duration' : str(pass_duration),\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time   # new obs time = prev set time\n                    contacts.append(pass_data)\n\n                # increase time by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return contacts\n","state":"done","pos":0,"type":"cell","end":1497471954832,"id":"baca65","kernel":"anaconda3"}
{"exec_count":58,"input":"# Import necessary libraries\nimport ephem\nimport math\nfrom datetime import timedelta\n\n\n# get_passes() function definition\ndef new_get_passes(observer, tle, start_time, num_passes=None, duration=None):\n    \"\"\"Config obs and sat, Return pass data for all passes in given interval.\n\n    Arguments:\n    observer -- 4 element list containing desired [name,lat,lon,alt]\n    tle -- 3 element list containing desired tle [line0,line1,line2]\n    start_time -- ephem.date string formatted 'yyyy/mm/dd hr:min:sec'\n    num_passes -- integer number of desired passes (defualt None)\n    duration -- float number of hours or fraction of hours (default None)\n\n    Specify either num_passes or duration.\n    If both, use min(num_passes, duration).\n    If neither, find passes for next 24 hours.\n    \"\"\"\n\n    obs_name, obs_lat, obs_lon, obs_alt = observer\n    tle_line0, tle_line1, tle_line2 = tle\n\n    # Set up location of observer\n    ground_station = ephem.Observer()\n    ground_station.name = obs_name                # name string\n    ground_station.lon = obs_lon                  # in degrees (+E)\n    ground_station.lat = obs_lat                  # in degrees (+N)\n    ground_station.elevation = obs_alt            # in meters\n    ground_station.date = ephem.date(start_time)  # in UTC\n\n    # Read in most recent satellite TLE data\n    sat = ephem.readtle(tle_line0, tle_line1, tle_line2)\n\n    contacts = []\n\n    if duration is None and num_passes is None:\n        # get passes for next 24 hrs\n        duration = 24\n        # set num_passes > max passes possible in duration.\n        # duration is in hours, so 4 per hour is large\n        # enough for duration to break out of loop.\n        num_passes = 4 * int(duration)\n        # set end_time longer than suggested length for tle's\n        end_time = ephem.date(ground_station.date+5*365)\n    if duration is not None and num_passes is None:\n        # set num_passes > max passes possible in duration.\n        # duration is in hours, so 4 per hour is large\n        # enough for duration to break out of loop.\n        num_passes = 4 * int(duration)\n        end_time = ephem.date(ground_station.date+duration*ephem.hour)\n    if duration is None and num_passes is not None:\n        # set end_time longer than suggested length for tle's\n        end_time = ephem.date(ground_station.date+5*365)\n    if num_passes is not None and duration is not None:\n        # if both are given, use minimum\n        end_time = ephem.date(ground_station.date+duration*ephem.hour)\n\n    try:\n        for i in range(num_passes):\n            if ground_station.date > end_time:\n                break\n            sat.compute(ground_station)  # compute all body attributes for sat\n            # next pass command yields array with [0]=rise time,\n            # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n            # [4]=set time, [5]=set azimuth\n            info = ground_station.next_pass(sat)\n            rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n            deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n            pass_duration = timedelta(days=set_time-rise_time)  # timedelta\n\n            pass_data = {\n                'start': rise_time.datetime().ctime(),\n                'end': set_time.datetime().ctime(),\n                'duration': str(pass_duration),\n                'rise_az': (rise_az*deg_per_rad),\n                'set_az': (set_az*deg_per_rad)\n            }\n\n            if set_time > rise_time:  # only update if set time > rise time\n                ground_station.date = set_time  # new obs time = prev set time\n                if ground_station.date <= end_time:\n                    contacts.append(pass_data)\n\n            # increase by 1 min and look for next pass\n            ground_station.date = ground_station.date + ephem.minute\n    except ValueError:\n        # No (more) visible passes\n        pass\n    return contacts\n","state":"done","pos":1,"type":"cell","id":"db2f1f","kernel":"anaconda3"}
{"exec_count":61,"start":1497538739871,"input":"from itertools import islice\ndata = []\nwith open('amateur.txt') as f:\n    while True:\n        #an iterator that returns the next N lines and stops\n        tripleline = islice(f, 3)\n        #loop over these N lines, removing trailing spaces and \\n\n        tle = [x.rstrip() for x in tripleline]\n\n        #only accept complete data\n        #the end of the file *should* have len(tle)==0 but\n        #this also handles extra junk at the end\n        if len(tle) == 3:\n            data.append(tle)\n        else:\n            break\n\nvu = ['Valparaiso University', '41.4639', '-87.0439', 245.089]\nstart_time = '2017/6/14 15:00:00'\nnum_passes = 50\nduration = None\nvu_passes = {}\nnew_vu_passes = {}\n\nfor tle in data:\n    # use NORAD ID as key for each satellite\n    # value is list of passes, where each pass is a dictionary of data\n    noradID = tle[2][2:7]\n    vu_passes[noradID] = get_passes(vu, tle, start_time, num_passes=num_passes, duration=duration)\n    new_vu_passes[noradID] = new_get_passes(vu, tle, start_time, num_passes=num_passes, duration=duration)","state":"done","pos":2,"type":"cell","end":1497538779639,"id":"2d38d4","kernel":"anaconda3"}
{"output":{"0":{"data":{"text/plain":"True"},"exec_count":62}},"exec_count":62,"start":1497538782470,"input":"vu_passes == new_vu_passes","scrolled":true,"state":"done","pos":3,"type":"cell","end":1497538782491,"id":"13a6ab","kernel":"anaconda3"}
{"output":{"0":{"more_output":true}},"exec_count":46,"start":1497472685321,"input":"import pprint\npprint.pprint(new_vu_passes)","scrolled":true,"state":"done","pos":4,"type":"cell","end":1497472685990,"id":"5b3f6c","kernel":"anaconda3"}