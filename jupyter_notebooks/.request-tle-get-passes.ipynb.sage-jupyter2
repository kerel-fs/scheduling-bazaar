{"type":"settings","kernel":"anaconda3","backend_state":"running","trust":true,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.5.3"}},"kernel_state":"idle"}
{"type":"file","last_load":1497282136495}
{"output":{"0":{"text":"[{'rise_az': 190.456669458409, 'end': 'Thu Jun  8 19:35:05 2017', 'duration': '0:09:29.955764', 'set_az': 70.48850846101539, 'start': 'Thu Jun  8 19:25:35 2017'}, {'rise_az': 238.95741928294103, 'end': 'Thu Jun  8 21:11:59 2017', 'duration': '0:11:03.015994', 'set_az': 53.80764288509183, 'start': 'Thu Jun  8 21:00:56 2017'}]\n","name":"stdout"}},"exec_count":103,"start":1497379736987,"input":"vu = ['Valparaiso University', '41.4639', '-87.0439', 245.089]\nstart_time = '2017/6/8 12:00:00'\nnum_passes = 2\nduration = None\nvu_passes = {}\ni = 0\n\nfor tle in data:\n    # use NORAD ID as key for each satellite\n    # value is list of passes, where each pass is a dictionary of data\n    vu_passes[data[i][2][2:7]] = get_passes(vu, tle, start_time, num_passes=num_passes, duration=duration)\n    i = i + 1\n\nprint(vu_passes['25544'])","scrolled":true,"state":"done","pos":3,"cell_type":"code","type":"cell","end":1497379737635,"id":"45ac85","kernel":"anaconda3"}
{"exec_count":97,"start":1497295170582,"input":"# Import necessary libraries\nimport ephem\nimport math\nfrom datetime import timedelta\nfrom datetime import datetime\n\n\n# get_passes() function definition\ndef get_passes(observer, tle, start_time, num_passes=None, duration=None):\n    \"\"\"Config obs and sat, Return pass data for all passes in given interval.\n\n    Arguments:\n    observer -- 4 element list containing desired [name,lat,lon,alt]\n    tle -- 3 element list containing desired tle [line0,line1,line2]\n    start_time -- ephem.date string formatted 'yyyy/mm/dd hr:min:sec'\n    num_passes -- integer number of desired passes (defualt None)\n    duration -- float number of hours or fraction of hours (default None)\n\n    Specify either num_passes or duration.\n    If both, use num_passes.\n    If neither, find passes for next 24 hours.\n    \"\"\"\n\n    obs_name, obs_lat, obs_lon, obs_alt = observer\n    tle_line0, tle_line1, tle_line2 = tle\n\n    # Set up location of observer\n    ground_station = ephem.Observer()\n    ground_station.name = obs_name                # name string\n    ground_station.lon = obs_lon                  # in degrees (+E)\n    ground_station.lat = obs_lat                  # in degrees (+N)\n    ground_station.elevation = obs_alt            # in meters\n    ground_station.date = ephem.date(start_time)  # in UTC\n\n    # Read in most recent satellite TLE data\n    sat = ephem.readtle(tle_line0, tle_line1, tle_line2)\n\n    contacts = []\n\n    if num_passes is not None and duration is None:\n        # if only num_passes specified\n        try:\n            for i in range(num_passes):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = timedelta(days = set_time-rise_time)  # fraction of a day\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time  # new obs time = prev set time\n\n                pass_data = {\n                    'start' : rise_time.datetime().ctime(),\n                    'end' : set_time.datetime().ctime(),\n                    'duration' : str(pass_duration),\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                # increase by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n                contacts.append(pass_data)\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return contacts\n\n    if num_passes is None and duration is not None:\n        # if only duration specified\n        try:\n            end_time = ephem.date(ground_station.date+duration*ephem.hour)\n            while (ground_station.date <= end_time):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = timedelta(set_time-rise_time)  # fraction of a day\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time  # new obs time = prev set time\n\n                pass_data = {\n                    'start' : rise_time.datetime().ctime(),\n                    'end' : set_time.datetime().ctime(),\n                    'duration' : str(pass_duration),\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                # increase time by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return pass_data\n\n    if num_passes is not None and duration is not None:\n        # if both are specified, use num_passes\n        try:\n            for i in range(num_passes):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = timedelta(set_time-rise_time)  # fraction of a day\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time   # new obs time = prev set time\n\n                pass_data = {\n                    'start' : rise_time.datetime().ctime(),\n                    'end' : set_time.datetime().ctime(),\n                    'duration' : str(pass_duration),\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                # increase time by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return pass_data\n\n    if num_passes is None and duration is None:\n        # if neither are specified, get passes for the next 24 hours\n        try:\n            end_time = ephem.date(ground_station.date+1)\n            while (ground_station.date <= end_time):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = timedelta(set_time-rise_time)  # fraction of a day\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time   # new obs time = prev set time\n\n                pass_data = {\n                    'start' : rise_time.datetime().ctime(),\n                    'end' : set_time.datetime().ctime(),\n                    'duration' : str(pass_duration),\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                # increase time by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return pass_data\n","state":"done","pos":0,"cell_type":"code","type":"cell","end":1497295171086,"id":"84a419","kernel":"anaconda3"}
{"exec_count":98,"start":1497295171571,"input":"import requests","state":"done","pos":1,"cell_type":"code","type":"cell","end":1497295171575,"id":"f77ee3","kernel":"anaconda3"}
{"exec_count":99,"start":1497295172069,"input":"# itertools has lots of things that deal with looping\n# \"generators\" and \"iterators\" are really nice concepts that\n#can be used in place of most usage of using indexes in a loop\n#because usually we aren't actually interested in counting the lines\nfrom itertools import islice\ndata = []\nwith open('amateur.txt') as f:\n    #we don't know we've reached the end of the file\n    #until we actually reached it\n    while True:\n        #an iterator that returns the next N lines and stops\n        tripleline = islice(f, 3)\n        #loop over these N lines, removing trailing spaces and \\n\n        # this is called a \"list comprehension\"\n        # it is pretty much exactly the same as\n        #    tle = []\n        #    for line in tripleline:\n        #      tle.append(x.rstrip())\n        #\n        tle = [x.rstrip() for x in tripleline]\n        \n        #only accept complete data\n        #the end of the file *should* have len(tle)==0 but\n        #this also handles extra junk at the end\n        if len(tle) == 3:\n            data.append(tle)\n        else:\n            break\n\n# now, data is a list of 3-element lists of strings","state":"done","pos":2,"cell_type":"code","type":"cell","end":1497295172080,"id":"27f2b7","kernel":"anaconda3"}
{"output":{"0":{"text":"07530\n14781\n","name":"stdout"}},"exec_count":100,"start":1497295172573,"input":"# get NORAD ID for each sat\nprint(data[0][2][2:7])\nprint(data[1][2][2:7])","state":"done","pos":2.5,"type":"cell","end":1497295172577,"id":"79ae63","kernel":"anaconda3"}
{"output":{"0":{"more_output":true}},"exec_count":104,"start":1497379739579,"input":"import pprint\npprint.pprint(vu_passes)","scrolled":false,"state":"done","pos":4,"type":"cell","end":1497379739901,"id":"b05c93","kernel":"anaconda3"}