{"type":"settings","kernel":"anaconda3","backend_state":"running","trust":true,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.5.3"}},"kernel_state":"idle"}
{"type":"file","last_load":1497282136495}
{"output":{"0":{"text":"[{'rise_az': 190.456669458409, 'end': 42893.31604054287, 'duration': 0.006596710234589409, 'set_az': 70.48850846101539, 'start': 42893.30944383264}, {'rise_az': 238.95741928294103, 'end': 42893.383323068636, 'duration': 0.007673796222661622, 'set_az': 53.80764288509183, 'start': 42893.37564927241}, {'rise_az': 277.83698705767466, 'end': 42893.4503480843, 'duration': 0.007075859924952965, 'set_az': 52.31765419312647, 'start': 42893.44327222437}, {'rise_az': 302.7234369967764, 'end': 42893.517890297146, 'duration': 0.006818195070081856, 'set_az': 68.37534355446182, 'start': 42893.511072102076}, {'rise_az': 308.7222555410152, 'end': 42893.58574590428, 'duration': 0.0074637355719460174, 'set_az': 101.9204174741996, 'start': 42893.57828216871}, {'rise_az': 299.42355404268983, 'end': 42893.65275732826, 'duration': 0.007447332063748036, 'set_az': 145.65946676791137, 'start': 42893.645309996195}, {'rise_az': 266.29276524705915, 'end': 42893.717289505425, 'duration': 0.003657167195342481, 'set_az': 207.99816619051086, 'start': 42893.71363233823}, {'rise_az': 172.0191611902282, 'end': 42894.27945357588, 'duration': 0.005428640099125914, 'set_az': 80.43525147760243, 'start': 42894.27402493578}, {'rise_az': 225.76202656123164, 'end': 42894.347125270404, 'duration': 0.007636293914401904, 'set_az': 56.98934990615887, 'start': 42894.33948897649}, {'rise_az': 267.35554268191316, 'end': 42894.41411787288, 'duration': 0.007298769887711387, 'set_az': 51.173310639204196, 'start': 42894.406819102995}]\n","name":"stdout"}},"exec_count":31,"start":1497289996806,"input":"vu = ['Valparaiso University', '41.4639', '-87.0439', 245.089]\nstart_time = '2017/6/8 12:00:00'\nnum_passes = 10\nduration = None\nvu_passes = {}\ni = 0\n\nfor tle in data:\n    # use NORAD ID as key for each satellite\n    # value is list of passes, where each pass is a dictionary of data\n    vu_passes[data[i][2][2:7]] = get_passes(vu, tle, start_time, num_passes=num_passes, duration=duration)\n    i = i + 1\n\nprint(vu_passes['25544'])","scrolled":true,"state":"done","pos":3,"cell_type":"code","type":"cell","end":1497290000726,"id":"45ac85","kernel":"anaconda3"}
{"exec_count":1,"start":1497282143970,"input":"# Import necessary libraries\nimport ephem\nimport math\n\n\n# get_passes() function definition\ndef get_passes(observer, tle, start_time, num_passes=None, duration=None):\n    \"\"\"Config obs and sat, Return pass data for all passes in given interval.\n\n    Arguments:\n    observer -- 4 element list containing desired [name,lat,lon,alt]\n    tle -- 3 element list containing desired tle [line0,line1,line2]\n    start_time -- ephem.date string formatted 'yyyy/mm/dd hr:min:sec'\n    num_passes -- integer number of desired passes (defualt None)\n    duration -- float number of hours or fraction of hours (default None)\n\n    Specify either num_passes or duration.\n    If both, use num_passes.\n    If neither, find passes for next 24 hours.\n    \"\"\"\n\n    obs_name, obs_lat, obs_lon, obs_alt = observer\n    tle_line0, tle_line1, tle_line2 = tle\n\n    # Set up location of observer\n    ground_station = ephem.Observer()\n    ground_station.name = obs_name                # name string\n    ground_station.lon = obs_lon                  # in degrees (+E)\n    ground_station.lat = obs_lat                  # in degrees (+N)\n    ground_station.elevation = obs_alt            # in meters\n    ground_station.date = ephem.date(start_time)  # in UTC\n\n    # Read in most recent satellite TLE data\n    sat = ephem.readtle(tle_line0, tle_line1, tle_line2)\n\n    contacts = []\n\n    if num_passes is not None and duration is None:\n        # if only num_passes specified\n        try:\n            for i in range(num_passes):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = (set_time-rise_time)  # fraction of a day\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time  # new obs time = prev set time\n\n                pass_data = {\n                    'start' : rise_time,\n                    'end' : set_time,\n                    'duration' : pass_duration,\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                # increase by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n                contacts.append(pass_data)\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return contacts\n\n    if num_passes is None and duration is not None:\n        # if only duration specified\n        try:\n            end_time = ephem.date(ground_station.date+duration*ephem.hour)\n            while (ground_station.date <= end_time):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = (set_time-rise_time)  # fraction of a day\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time  # new obs time = prev set time\n\n                pass_data = {\n                    'start' : rise_time,\n                    'end' : set_time,\n                    'duration' : pass_duration,\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                # increase time by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return pass_data\n\n    if num_passes is not None and duration is not None:\n        # if both are specified, use num_passes\n        try:\n            for i in range(num_passes):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = (set_time-rise_time)  # fraction of a day\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time   # new obs time = prev set time\n\n                pass_data = {\n                    'start' : rise_time,\n                    'end' : set_time,\n                    'duration' : pass_duration,\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                # increase time by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return pass_data\n\n    if num_passes is None and duration is None:\n        # if neither are specified, get passes for the next 24 hours\n        try:\n            end_time = ephem.date(ground_station.date+1)\n            while (ground_station.date <= end_time):\n                sat.compute(ground_station)  # compute all body attributes for sat\n                # next pass command yields array with [0]=rise time,\n                # [1]=rise azimuth, [2]=max alt time, [3]=max alt,\n                # [4]=set time, [5]=set azimuth\n                info = ground_station.next_pass(sat)\n                rise_time, rise_az, max_alt_time, max_alt, set_time, set_az = info\n                deg_per_rad = 180.0/math.pi           # use to conv azimuth to deg\n                pass_duration = (set_time-rise_time)  # fraction of a day\n\n                if set_time > rise_time:  # only update if set time > rise time\n                    ground_station.date = set_time   # new obs time = prev set time\n\n                pass_data = {\n                    'start' : rise_time,\n                    'end' : set_time,\n                    'duration' : pass_duration,\n                    'rise_az' : (rise_az*deg_per_rad),\n                    'set_az' : (set_az*deg_per_rad)\n                }\n\n                # increase time by 1 min and look for next pass\n                ground_station.date = ground_station.date + ephem.minute\n        except ValueError:\n            # No (more) visible passes\n            pass\n        return pass_data\n","state":"done","pos":0,"cell_type":"code","type":"cell","end":1497282144577,"id":"84a419","kernel":"anaconda3"}
{"exec_count":2,"start":1497282144580,"input":"import requests","state":"done","pos":1,"cell_type":"code","type":"cell","end":1497282145681,"id":"f77ee3","kernel":"anaconda3"}
{"exec_count":8,"start":1497283929819,"input":"# itertools has lots of things that deal with looping\n# \"generators\" and \"iterators\" are really nice concepts that\n#can be used in place of most usage of using indexes in a loop\n#because usually we aren't actually interested in counting the lines\nfrom itertools import islice\ndata = []\nwith open('amateur.txt') as f:\n    #we don't know we've reached the end of the file\n    #until we actually reached it\n    while True:\n        #an iterator that returns the next N lines and stops\n        tripleline = islice(f, 3)\n        #loop over these N lines, removing trailing spaces and \\n\n        # this is called a \"list comprehension\"\n        # it is pretty much exactly the same as\n        #    tle = []\n        #    for line in tripleline:\n        #      tle.append(x.rstrip())\n        #\n        tle = [x.rstrip() for x in tripleline]\n        \n        #only accept complete data\n        #the end of the file *should* have len(tle)==0 but\n        #this also handles extra junk at the end\n        if len(tle) == 3:\n            data.append(tle)\n        else:\n            break\n\n# now, data is a list of 3-element lists of strings","state":"done","pos":2,"cell_type":"code","type":"cell","end":1497283929874,"id":"27f2b7","kernel":"anaconda3"}
{"output":{"0":{"text":"07530\n14781\n","name":"stdout"}},"exec_count":11,"input":"# get NORAD ID for each sat\nprint(data[0][2][2:7])\nprint(data[1][2][2:7])","state":"done","pos":2.5,"type":"cell","id":"79ae63","kernel":"anaconda3"}
{"output":{"0":{"more_output":true}},"exec_count":32,"start":1497290003470,"input":"import pprint\npprint.pprint(vu_passes)","scrolled":true,"state":"done","pos":4,"type":"cell","end":1497290004916,"id":"b05c93","kernel":"anaconda3"}